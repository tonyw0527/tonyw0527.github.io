{"componentChunkName":"component---src-templates-blog-post-js","path":"/call-by-value/","result":{"data":{"site":{"siteMetadata":{"title":"Tony's Blog"}},"markdownRemark":{"id":"2f9440c9-e3d3-502e-92e6-1132475f8ba6","excerpt":"Primitive Type 자바스크립트에는 boolean, number, string, null, undefined 5 가지의 원시 타입(primitive type)이 있습니다. 원시 타입은 변수에 값 자체를 할당합니다. 따라서 const…","html":"<h2>Primitive Type</h2>\n<p>자바스크립트에는 boolean, number, string, null, undefined 5 가지의 원시 타입(primitive type)이 있습니다.</p>\n<p>원시 타입은 변수에 값 자체를 할당합니다. 따라서 const로 선언된 상수에는 값을 변경할 수 없죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 5</span>\n\nfoo <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught TypeError: Assignment to constant variable.</span></code></pre></div>\n<h2>Object Type</h2>\n<p>반면에 자바스크립트의 객체 타입(Object Type)은 변수에 객체의 참조 주소를 값으로 할당합니다.</p>\n<p>따라서 아래와 같이 const로 객체를 선언한 후에 해당 상수를 통해 객체의 프로퍼티를 설정해도 오류가 나지 않죠. 프로퍼티를 바꾸는 것이지 const에 할당된 참조 주소를 변경하는 것이 아니기 때문이죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'kim'</span>\n<span class=\"token punctuation\">}</span>\n\nobj<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">21</span><span class=\"token punctuation\">;</span>\n\nobj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// Uncaught TypeError: Assignment to constant variable.</span>\n  reset<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>참조 주소 - 메모리에 할당된 값이 저장된 주소</p>\n</blockquote>\n<h2>Call by value</h2>\n<p>Call by value와 Call by reference는 함수를 호출할 때 arguments들을 어떤 방식으로 불러오느냐를 나타내는 말입니다.</p>\n<p>글의 제목처럼 자바스크립트는 Call by value 방식으로 함수를 호출합니다.</p>\n<p><strong>원시 타입</strong>인 경우에는 call by value라는 의미 그대로 이해하기가 쉬울 것 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> num <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">changeNum</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  n <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">changeNum</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span></code></pre></div>\n<p>changeNum이라는 함수에 num 변수를 파라미터로 넣어주어도 num 변수의 값을 복사했기 때문에 changeNum 내부에서 파라미터에 할당된 값을 변경하여도 함수 밖의 num 변수의 값은 변화없이 1이 출력됩니다.</p>\n<p><strong>객체 타입</strong>\n반면에 객체 타입일 때 아래와 같은 경우일 때가 자바스크립트의 함수 호출이 call by reference라고 착각하게 되는 경우일 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  isGood<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">changeObj</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">o</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  o<span class=\"token punctuation\">.</span>isGood <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj <span class=\"token operator\">===</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true - obj와 o가 같은 값을 참조하고 있음.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">changeObj</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>isGood<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>위에서 객체 타입은 변수에 참조 주소를 값으로 설명드렸죠? 함수의 파라미터도 마찬가지라고 생각하면 됩니다. 함수 파라미터에도 변수와 마찬가지로 참조 <em>주소의 값이 복사</em>(call by value)되어 들어간 것이죠. 함수의 파라미터를 그냥 일반 변수라고 생각하면 이해하시기 쉬울 것입니다. 따라서 아래와 같은 경우가 생기는 것이죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  isGood<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">changeObj</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">o</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    isGood<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj <span class=\"token operator\">===</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false - obj와 o가 다른 값을 참조한다.</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">changeObj</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>함수의 파라미터 o에는 새로운 객체의 참조 주소값이 할당 되었기 때문입니다. 여기서 알 수 있듯이 함수의 파라미터는 일반 변수들 처럼 단순히 값을 복사 받아서(call by value) 함수 내부에서 사용하는 것이죠.</p>\n<h2>Call by reference</h2>\n<p>C언어를 예를 들고 싶은데 코드를 빼고 간단하게 말로 적어보자면, Call by reference 방식의 경우 함수의 파라미터는 메모리 상의 값이 할당된 참조 주소를 의미합니다. call by value에서는 함수 파라미터의 값들을 새로 할당해 줄 수 있지만, call by reference 방식에서 함수 파라미터는 함수 인자로 받은 참조 주소를 계속해서 가르킵니다.</p>\n<p>무슨 의미냐 하면은 만약 자바스크립트가 call by reference로 객체 타입 파라미터들을 다룰 수 있었다면 아래와 같았을 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  isGood<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">changeObj</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">o</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  o <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    isGood<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj <span class=\"token operator\">===</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true - obj와 o가 같은 값을 참조한다. 만약 자바스크립트가 call by reference 였다면!</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">changeObj</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>보충학습 - shallow clone &#x26; deep clone</h2>\n<p>자바스크립트의 함수 호출 방식이 call by value인 것을 알았습니다. 그렇다면 보충학습으로 자바스크립트의 객체는 어떻게 복사할 수 있을까요?</p>\n<p>자바스크립트의 객체는 변수에 참조값을 할당합니다. 때문에 아래와 같은 코드에서는 obj1과 같은 내용을 가지고 있지만 참조값이 독립된 객체가 obj2에 복사되는 것이 아니고 obj1과 같은 참조값을 복사받게 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  foo<span class=\"token operator\">:</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> obj2 <span class=\"token operator\">=</span> obj1<span class=\"token punctuation\">;</span></code></pre></div>\n<p>그렇다면 어떻게해야 독립된 객체로 복사할 수 있을까요? 여러 방법이 있고 우선 복사정도에 따라 얕은 복사(shallow clone)와 깊은 복사(deep clone)가 있습니다.</p>\n<p>이렇게 두 가지의 복사 형태로 나뉘게 되는 이유는 객체가 내부에 객체 타입의 프라퍼티를 가지고 있는 경우에 발생됩니다. 객체가 가지고 있는 원시타입들은 새롭게 값이 복사되지만 객체 타입의 프라퍼티들은 변수에 객체가 참조값이 할당되는 것처럼 동일하게 참조값이 복사되기 때문이죠.</p>\n<p>** 얕은 복사 **는 아래와 같은 방법으로 가능합니다.</p>\n<ul>\n<li>Object.assign()</li>\n<li>ES6 spread operator</li>\n</ul>\n<p>** 깊은 복사 **는 아래와 같은 방법으로 가능합니다.</p>\n<ul>\n<li>Lodash 라이브러리의 deepclone 함수 사용하기</li>\n</ul>","frontmatter":{"title":"자바스크립트의 함수 호출 방식은 Call by value 입니다.","date":"May 12, 2021","description":"Primitive type, Object Type, Call by value, Call by reference를 이해하고 나아가 Shallow clone과 deep clone에 대해서도 알아봅시다."}},"previous":{"fields":{"slug":"/event-delegation/"},"frontmatter":{"title":"DOM이벤트에서 이벤트 위임까지"}},"next":{"fields":{"slug":"/html5/"},"frontmatter":{"title":"HTML5 정리"}},"allMarkdownRemark":{"nodes":[{"excerpt":"XML과 HTML XML은 Extensible Markup Language의 약자로 다목적으로 사용되는 마크업 언어입니다. HTML, JSX등의 마크업 언어를 포함하는 것이 XML이라고 볼 수 있습니다. XML…","fields":{"slug":"/html5/"},"frontmatter":{"date":"May 27, 2021","title":"HTML5 정리","description":"HTML5를 CheatSheet 형태로 정리하였습니다."}},{"excerpt":"Primitive Type 자바스크립트에는 boolean, number, string, null, undefined 5 가지의 원시 타입(primitive type)이 있습니다. 원시 타입은 변수에 값 자체를 할당합니다. 따라서 const…","fields":{"slug":"/call-by-value/"},"frontmatter":{"date":"May 12, 2021","title":"자바스크립트의 함수 호출 방식은 Call by value 입니다.","description":"Primitive type, Object Type, Call by value, Call by reference를 이해하고 나아가 Shallow clone과 deep clone에 대해서도 알아봅시다."}},{"excerpt":"DOM 이벤트 각 DOM 요소들은 특정한 조건을 감지하였을 때, DOM 이벤트를 발생시킵니다. 그리고 이렇게 발생 된 DOM 이벤트를 제어하기 위해 이벤트 핸들러를 각 DOM 요소에 등록하여 사용합니다. 이벤트 흐름 표준 DOM 이벤트에서는…","fields":{"slug":"/event-delegation/"},"frontmatter":{"date":"May 10, 2021","title":"DOM이벤트에서 이벤트 위임까지","description":"DOM 이벤트의 이벤트 흐름에 대해 살펴보고 이벤트 위임을 알아봅시다."}},{"excerpt":"Babel이란? Babel은 ECMAScript 2015+(ES6+) 이상 버전의 Javascript 코드를 인터넷 익스플로러 같은 이전 버전의 Javascript 엔진에서 실행 가능한 이전 버전의 Javascript…","fields":{"slug":"/babel/"},"frontmatter":{"date":"May 08, 2021","title":"Babel 정리","description":"Parsing, Transforming, Printing 바벨의 기본 구조에 대해 알아봅시다."}},{"excerpt":"…","fields":{"slug":"/webpack/"},"frontmatter":{"date":"May 06, 2021","title":"WEBPACK 정리","description":"웹팩에 대한 내용들을 정리했습니다."}},{"excerpt":"자바스크립트 비동기를 위해 알아야하는 키워드 동기(sync) & 비동기(async) 1번, 2번, 3번이라고 부르는 세 가지 일이 있다고 하자 동기 - 1번 작업이 끝나면 2번 작업을 시작, 2번 작업이 끝나면 3번 작업이 시작 비동기 - 1번,…","fields":{"slug":"/자바스크립트-비동기/"},"frontmatter":{"date":"May 05, 2021","title":"자바스크립트의 비동기","description":"자바스크립트 비동기에 대해 알아봅시다."}},{"excerpt":"기존에 Tistory…","fields":{"slug":"/블로그를-시작하며/"},"frontmatter":{"date":"May 04, 2021","title":"블로그를 시작하며","description":"새롭게 블로그를 시작합니다 :)"}},{"excerpt":"This is my first post on my new fake blog! How exciting! I’m sure I’ll write a lot more interesting things in the future. Oh, and here’s a…","fields":{"slug":"/hello-world/"},"frontmatter":{"date":"May 01, 2015","title":"Hello World","description":"Hello World"}}]}},"pageContext":{"id":"2f9440c9-e3d3-502e-92e6-1132475f8ba6","previousPostId":"105fc171-e8ac-521c-a4f8-d6227474c194","nextPostId":"ed02e2e1-a5dd-57a4-bc96-6674e7315b36"}},"staticQueryHashes":["2841359383","3257411868"]}